<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[物联网应用层协议选择和分析--MQTT、CoAP 、HTTP、XMPP、SoAP]]></title>
    <url>%2FIoT-AppServer-Protocol.html</url>
    <content type="text"><![CDATA[Quick StartMQTT协议MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）最早是IBM开发的一个即时通讯协议，MQTT协议是为大量计算能力有限且工作在低带宽、不可靠网络的远程传感器和控制设备通讯而设计的一种协议。MQTT协议的优势是可以支持所有平台，它几乎可以把所有的联网物品和互联网连接起来。它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布和应用程序之间的解耦； 消息传输不需要知道负载内容； 使用 TCP/IP 提供网络连接； 有三种消息发布的服务质量：QoS 0：“最多一次”，消息发布完全依赖底层 TCP/IP 网络。分发的消息可能丢失或重复。例如，这个等级可用于环境传感器数据，单次的数据丢失没关系，因为不久后还会有第二次发送。QoS 1：“至少一次”，确保消息可以到达，但消息可能会重复。QoS 2：“只有一次”，确保消息只到达一次。例如，这个等级可用在一个计费系统中，这里如果消息重复或丢失会导致不正确的收费。 小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量； 使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制； 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT的传输格式非常精小，最小的数据包只有2个bit，且无应用消息头。下图是MQTT为可靠传递消息的三种消息发布服务质量 发布/订阅模型允许MQTT客户端以一对一、一对多和多对一方式进行通讯。下图是MQTT的发布／订阅消息模式 CoAPCoAP是受限制的应用协议(Constrained Application Protocol)的代名词。由于目前物联网中的很多设备都是资源受限型的，所以只有少量的内存空间和有限的计算能力，传统的HTTP协议在物联网应用中就会显得过于庞大而不适用。因此，IETF的CoRE工作组提出了一种基于REST架构、传输层为UDP、网络层为6LowPAN（面向低功耗无线局域网的IPv6）的CoAP协议。CoAP采用与HTTP协议相同的请求响应工作模式。CoAP协议共有4中不同的消息类型。 CON——需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。 NON——不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。 ACK——应答消息，接受到CON消息的响应。 RST——复位消息，当接收者接受到的消息包含一个错误，接受者解析消息或者不再关心发送者发送的内容，那么复位消息将会被发送。 CoAP消息格式使用简单的二进制格式，最小为4个字节。一个消息 = 固定长度的头部header + 可选个数的option + 负载payload。Payload的长度根据数据报长度来计算主要是一对一的协议 举个例子：比如某个设备需要从服务器端查询当前温度信息。请求消息（CON）： GET /temperature , 请求内容会被包在CON消息里面响应消息 (ACK)： 2.05 Content “22.5 C” ，响应内容会被放在ACK消息里面 CoAP与MQTT的区别MQTT和CoAP都是行之有效的物联网协议，但两者还是有很大区别的，比如MQTT协议是基于TCP，而CoAP协议是基于UDP。从应用方向来分析，主要区别有以下几点： MQTT协议不支持带有类型或者其它帮助Clients理解的标签信息，也就是说所有MQTT Clients必须要知道消息格式。而CoAP协议则相反，因为CoAP内置发现支持和内容协商，这样便能允许设备相互窥测以找到数据交换的方式。 MQTT是长连接而CoAP是无连接。MQTT Clients与Broker之间保持TCP长连接，这种情形在NAT环境中也不会产生问题。如果在NAT环境下使用CoAP的话，那就需要采取一些NAT穿透性手段。 MQTT是多个客户端通过中央代理进行消息传递的多对多协议。它主要通过让客户端发布消息、代理决定消息路由和复制来解耦消费者和生产者。MQTT就是相当于消息传递的实时通讯总线。CoAP基本上就是一个在Server和Client之间传递状态信息的单对单协议。 HTTP协议http的全称是HyperText Transfer Protocol，超文本传输协议，这个协议的提出就是为了提供和接收HTML界面，通过这个协议在互联网上面传出web的界面信息。HTTP协议的两个过程，Request和Response，两个都有各自的语言格式:请求报文格式：1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文格式：1234&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; method： 这个很重要，比如说GET和POST方法，这两个是很常用的，GET就是获取什么内容，而POST就是向服务器发送什么数据。当然还有其他的，比如HTTP 1.1中还有：DELETE、PUT、CONNECT、HEAD、OPTIONS、TRACE等一共8个方法（HTTP Method历史：HTTP 0.9 只有GET方法；HTTP 1.0 有GET、POST、HEAD三个方法）。 请求URL: 这里填写的URL是不包含IP地址或者域名的，是主机本地文件对应的目录地址，所以我们一般看到的就是“/”。 版本version： 格式是HTTP/.这样的格式，比如说HTTP/1.1.这个版本代表的就是我们使用的HTTP协议的版本，现在使用的一般是HTTP/1.1 状态码status: 状态码是三个数字，代表的是请求过程中所发生的情况，比如说200代表的是成功，404代表的是找不到文件。 原因短语reason-phrase： 状态码的可读版本，状态码就是一个数字，如果你事先不知道这个数字什么意思，可以先查看一下原因短语。 首部header： 注意这里的header我们不是叫做头，而是叫做首部。可能有零个首部也可能有多个首部，每个首部包含一个名字后面跟着一个冒号，然后是一个可选的空格，接着是一个值，然后换行。 实体的主体部分entity-body： 实体的主体部分包含一个任意数据组成的数据块，并不是所有的报文都包含实体的主体部分，有时候只是一个空行加换行就结束了。 下面我们举个简单的例子：123456789请求报文：GET /index.html HTTP/1.1 Accept: text/*Host: www.myweb.com响应报文：HTTP/1.1 200 OKContent-type: text/plainContent-length: 3 HTTP与CoAP的区别CoAP是6LowPAN协议栈中的应用层协议，基于REST（表述性状态传递）架构风格，支持与REST进行交互。通常用户可以像使用HTTP协议一样用CoAP协议来访问物联网设备。而且CoAP消息格式使用简单的二进制格式，最小为4个字节。HTTP使用报文格式对于嵌入式设备来说需要传输数据太多，太重，不够灵活。 XMPP协议XMPP（可扩展通讯和表示协议）是一种基于可扩展标记语言（XML）的协议，它继承了在XML环境中灵活的发展性。可用于服务类实时通讯、表示和需求响应服务中的XML数据元流式传输。XMPP以Jabber协议为基础，而Jabber是即时通讯中常用的开放式协议。 基本网络结构XMPP中定义了三个角色，客户端，服务器，网关。通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。 功能传输的是与即时通讯相关的指令。在以前这些命令要么用2进制的形式发送（比如QQ），要么用纯文本指令加空格加参数加换行符的方式发送（比如MSN）。而XMPP传输的即时通讯指令的逻辑与以往相仿，只是协议的形式变成了XML格式的纯文本。举个例子:客户端：123456&lt;?xmlversion=&apos;1.0&apos;?&gt;&lt;stream:streamto=&apos;example_com&apos;xmlns=&apos;jabber:client&apos;xmlns:stream=&apos;http_etherx_jabber_org/streams&apos;version=&apos;1.0&apos;&gt; 服务器：1234567&lt;?xmlversion=&apos;1.0&apos;?&gt;&lt;stream:streamfrom=&apos;example_com&apos;id=&apos;someid&apos;xmlns=&apos;jabber:client&apos;xmlns:stream=&apos;http_etherx_jabber_org/streams&apos;version=&apos;1.0&apos;&gt; 工作原理XMPP核心协议通信的基本模式就是先建立一个stream，然后协商一堆安全之类的东西，中间通信过程就是客户端发送XML Stanza，一个接一个的。服务器根据客户端发送的信息以及程序的逻辑，发送XML Stanza给客户端。但是这个过程并不是一问一答的，任何时候都有可能从一方发信给另外一方。通信的最后阶段是关闭流，关闭TCP/IP连接。 SoAP协议SoAP(简单对象访问协议)是交换数据的一种协议规范，是一种轻量的、简单的、基于可扩展标记语言（XML）的协议，它被设计成在WEB上交换结构化的和固化的信息。SOAP 可以和现存的许多因特网协议和格式结合使用，包括超文本传输协议（HTTP），简单邮件传输协议（SMTP），多用途网际邮件扩充协议（MIME）。它还支持从消息系统到远程过程调用（RPC）等大量的应用程序。SOAP使用基于XML的数据结构和超文本传输协议(HTTP)的组合定义了一个标准的方法来使用Internet上各种不同操作环境中的分布式对象。 总结：从当前物联网应用发展趋势来分析，MQTT协议具有一定的优势。因为目前国内外主要的云计算服务商，比如阿里云、AWS、百度云、Azure以及腾讯云都一概支持MQTT协议。还有一个原因就是MQTT协议比CoAP成熟的要早，所以MQTT具有一定的先发优势。但随着物联网的智能化和多变化的发展，后续物联网应用平台肯定会兼容更多的物联网应用层协议。 原文：https://blog.csdn.net/acongge2010/article/details/79142380]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的的物联网（IoT）协议]]></title>
    <url>%2FIoT-protocol.html</url>
    <content type="text"><![CDATA[许多通信技术是众所周知的，如WiFi，蓝牙，ZigBee和2G ／ 3G ／ 4G蜂窝，但也有几个新兴的新兴网络选项，如线程作为家庭自动化应用的替代品，以及在主要城市实施的空白电视技术用于更广泛的基于IoT的用例。根据应用，范围，数据要求，安全性和功率需求以及电池寿命等因素将决定某种形式的技术组合的选择。这些是向开发人员提供的一些主要通信技术。 Quick StartNB-IoTNB-IoT，Narrow Band Internet of Things，窄带物联网，是一种专为万物互联打造的蜂窝网络连接技术。顾名思义，NB-IoT所占用的带宽很窄，只需约180KHz，而且其使用License频段，可采取带内、保护带或独立载波三种部署方式，与现有网络共存，并且能够直接部署在GSM、UMTS或LTE网络，即2/3/4G的网络上，实现现有网络的复用，降低部署成本，实现平滑升级。NB-IoT具有以下四大特点： 广覆盖。相比现有的GSM、宽带LTE等网络覆盖增强了20dB，信号的传输覆盖范围更大（GSM基站目前理想状况下能覆盖35km），能覆盖到深层地下GSM网络无法覆盖到的地方。其原理主要依靠：1、缩小带宽，提升功率谱密度；2、重复发送，获得时间分集增益。 大连接。相比现有无线技术，同一基站下增多了50-100倍的接入数，每小区可以达到50K连接，真是实现万物互联所必须的海量连接。其原理在于：1、基于时延不敏感的特点，采用话务模型，保存更多接入设备的上下文，在休眠态和激活态之间切换；2、窄带物联网的上行调度颗粒小，资源利用率更高；3、减少空口信令交互，提升频谱密度。 低功耗。终端在99%的时间内均处在休眠态，并集成多种节电技术，待机时间可达10年。1、PSM低功耗模式，即在idle空闲态下增加PSM态 ，相当于关机，由定时器控制呼醒，耗能更低；2、eDRX扩展的非连续接收省电模式，采用更长的寻呼周期，eDRX是DRX耗电量的1/16。 低成本。硬件可剪裁，软件按需简化，确保了NB-IoT的成本低廉，NB-IoT通信单模块成本不足5美元。1234标准：全新的标准协议频率：800 MHz和900 MHz频段范围：N / A数据速率：NB-IoT射频带宽为200kHz。下行速率：大于160kbps，小于250kbps。上行速率：大于160kbps，小于250kbps(Multi-tone)/200kbps(Single-tone)。 详见：「深度剖析」工信部新增NB-IoT 800MHz和900MHz使用频段 GPRSGPRS是通用分组无线服务技术的简称，同时它也是GSM移动电话用户可用的一种移动数据业务，GPRS属于第二代移动通信中的数据传输技术。GPRS可说是GSM的延续。GPRS和以往连续在频道传输的方式不一样，它是以封包式的方式进行传输的，在使用中用户所负担的费用是以传输资料的单位进行计算的。并不是使用其整个频道， GPRS的传输速率可提升至56甚至114Kbps，GPRS具有充分利用现有的网络、传输速率高、资费较合理、资源利用率高、始终在线等特点。1234标准：2G/3G/4G频率：基于移动运营商范围：N / A数据速率：基于物联网卡，常见为56Kbps-114Kbps 蓝牙蓝牙技术是1994年爱立信公司提出的一种近距离无线通信规范，能够在设备之间进行方便快捷、低成本、低功耗的数据和语音传输，是无线个域网（WPAN）的主流技术之一。蓝牙的工作标准基于IEEE802．15．1，工作频段在2．4GHz，信道带宽1MHz，异步非对称连接最高数据速率732．2kbps（蓝牙2．0版支持10Mbps以上的速率），连接距离小于10m，使用高增益天线可是通信范围扩展到100m，由于蓝牙的上述特性使它可以应用于许多无线设备如图像处理设备、智能卡、身份识别设备等。蓝牙技术的缺点是：兼容性和抗干扰能力较差，传输距离较短，成本偏高。1234标准：蓝牙4．2核心规格频率：2．4GHz（ISM）范围：50－150米（智能／ BLE）数据速率：1Mbps（智能／ BLE） ZigbeeZigBee是一种无线连接，可工作在2．4GHz（全球流行）、868MHz（欧洲流行）和915 MHz（美国流行）3个频段上，分别具有最高250kbit／s、20kbit／s和40kbit／s的传输速率，它的传输距离在10—75m的范围内，但可以继续增加。作为一种无线通信技术，ZigBee具有如下特点： 低功耗： 由于ZigBee的传输速率低，发射功率仅为1mW，而且采用了休眠模式，功耗低，因此ZigBee设备非常省电。据估算，ZigBee设备仅靠两节5号电池就可以维持长达6个月到2年左右的使用时间，这是其它无线设备望尘莫及的。 成本低： ZigBee模块的初始成本在6美元左右，估计很快就能降到1．5—2．5美元， 并且ZigBee协议是免专利费的。低成本对于ZigBee也是一个关键的因素。 时延短： 通信时延和从休眠状态激活的时延都非常短，典型的搜索设备时延30ms，休眠激活的时延是15ms， 活动设备信道接入的时延为15ms。因此ZigBee技术适用于对时延要求苛刻的无线控制（如工业控制场合等）应用。 网络容量大： 一个星型结构的Zigbee网络最多可以容纳254个从设备和一个主设备， 一个区域内可以同时存在最多100个ZigBee网络， 而且网络组成灵活。 可靠： 采取了碰撞避免策略，同时为需要固定带宽的通信业务预留了专用时隙，避开了发送数据的竞争和冲突。MAC层采用了完全确认的数据传输模式， 每个发送的数据包都必须等待接收方的确认信息。如果传输过程中出现问题可以进行重发。 安全： ZigBee提供了基于循环冗余校验（CRC）的数据包完整性检查功能，支持鉴权和认证， 采用了AES—128的加密算法，各个应用可以灵活确定其安全属性。 1234标准：基于IEEE802．15．4的ZigBee 3．0频率：2．4GHz范围：10－100米数据速率：250kbps WIFIWIFI即IEEE802．11x，规定了协议的物理层（PHY）和媒体接入控制层（MAC），并依赖TCP／IP作为网络层，Wifi技术主要用来解决办公室局域网和校园网中用户与用户终端的无线接入。IEEE802．11的几个版本包括：802．11a，在5．8GHz频段最高速率54Mbps，在2．4GHz频段速度为1Mbps—11Mbps；802．11g在2．4GHz频段与802．11b兼容，最高速率为54Mbps。WIFI技术的优势在于无线电波覆盖广（100m）网络速度较高，移动性好，厂商进入此门槛低。通常Wifi拥有较高的带宽是以提高功耗为代价的，因此便携WIFI装置需要较高的电能储备，另外WiFi传输的数据质量有待改进，这限制了工业场合的推广。1234标准：基于802．11n（今天最常见的用途）频率：2．4GHz和5GHz频段范围：约50m数据速率：最大600 Mbps，但根据所使用的通道频率和天线数量（最新的802．11－ac标准应提供500Mbps至1Gbps），150－200Mbps更为典型。 Z波(Z－Wave)Z－Wave是一种低功耗射频通信技术，主要用于诸如灯控制器和传感器之类的产品的家庭自动化。针对数据速率高达100kbit ／ s的小数据数据包的可靠和低延迟通信进行了优化，其工作在1GHz频段，并且不受WiFi和其他无线技术在2．4 GHz范围内的干扰，如蓝牙或ZigBee。它支持全网状网络，而不需要协调器节点，并且是非常可扩展的，可以控制多达232个设备。 Z－Wave使用比其他一些更简单的协议，可以实现更快更简单的开发，但与其他无线技术（如ZigBee等）的多种来源相比，唯一的芯片制造商是Sigma Designs。1234标准：Z－Wave Alliance ZAD12837 ／ ITU－T G．9959频率：900MHz（ISM）范围：30m数据速率：9．6 ／ 40 ／ 100kbit ／ s 6LowPAN基于IP（Internet Protocol）的技术是6LowPAN（IPv6低功率无线个人区域网络）。 6LowPAN不是像蓝牙或ZigBee这样的IoT应用协议技术，而是一种定义封装和头压缩机制的网络协议。该标准具有频带和物理层的自由度，也可以在多种通信平台上使用，包括以太网，Wi－Fi，802．15．4和sub－1GHz ISM。一个关键的属性是IPv6（互联网协议版本6）堆栈，这是近年来非常重要的介绍，以实现物联网。 IPv6是IPv4的后继者，为世界上每个人提供大约5 x 1028个地址，使世界上任何嵌入式对象或设备都拥有自己的唯一IP地址并连接到互联网。例如，IPv6专为家庭或楼宇自动化设计，提供了一种基本的传输机制，可以通过低功耗无线网络以成本效益的方式生产复杂的控制系统和与设备进行通信。该标准旨在通过基于IEEE802．15．4的网络发送IPv6数据包，并实施开放IP标准，包括TCP，UDP，HTTP，COAP，MQTT和Websockets，该标准提供端对端可寻址节点，允许路由器将网络连接到IP。 6LowPAN是一种网状网络，具有强大的可扩展性和自愈性。网状路由器设备可以路由指定给其他设备的数据，而主机能够长时间睡眠。这里有6LowPAN的解释，TI提供。1234标准：RFC6282频率：（适用于各种其他网络媒体，包括蓝牙智能（2．4GHz）或ZigBee或低功率射频（亚1GHz）范围：N ／ A数据速率：N ／ A 线程线程是一种针对家庭自动化环境的新型基于IP的IPv6网络协议。基于6LowPAN，也喜欢它，它不是像蓝牙或ZigBee这样的IoT应用协议。然而，从应用的角度来看，它主要被设计为WiFi的补充，因为它识别出WiFi对于许多消费者设备而言是有利的，它在家庭自动化设置中使用的限制。线程组于2014年中推出，免版税协议基于各种标准，包括IEEE802．15．4（作为无线空中接口协议），IPv6和6LoWPAN，并为物联网提供了一种弹性的基于IP的解决方案。 Thread专为从现有的IEEE802．15．4无线芯片供应商（如飞思卡尔和Silicon Labs）工作，Thread支持使用IEEE802．15．4无线电收发器的网状网络，能够处理多达250个具有高级别身份验证和加密的节点。相对简单的软件升级应允许用户在现有的支持IEEE802．15．4的设备上运行线程。1234标准：线程，基于IEEE802．15．4和6LowPAN频率：2．4GHz（ISM）范围：N ／ A数据速率：N ／ A 蜂窝需要更长距离运行的IoT应用程序可以利用GSM ／ 3G ／ 4G蜂窝通信功能。虽然蜂窝电话显然能够发送大量的数据，特别是对于4G，但对于许多应用来说，费用和功耗将会太高，但是对于传输速度非常低的基于传感器的低带宽数据项目来说，这是非常理想的互联网上的数据量。该领域的一个关键产品是SparqEE系列产品，包括原始的小型CELLv1．0低成本开发板和一系列与Raspberry Pi和Arduino平台一起使用的屏蔽连接板。1234标准：GSM ／ GPRS ／ EDGE（2G），UMTS ／ HSPA（3G），LTE（4G）频率：900／1800／1900 ／ 2100MHz范围：GSM最大35km； HSPA最长200公里数据速率（典型下载）：35－170kps（GPRS），120－384kbps（EDGE），384Kbps－2Mbps（UMTS），600kbps－10Mbps（HSPA），3－10Mbps NFCNFC（近场通信）是一种技术，能够实现电子设备之间的简单和安全的双向交互，特别适用于智能手机，允许消费者执行非接触式支付交易，访问数字内容和连接电子设备。本质上它扩展了非接触式卡技术的能力，并使设备能够在距离小于4cm的情况下共享信息。此处提供更多信息。1234标准：ISO ／ IEC 18000－3频率：13．56MHz（ISM）范围：10厘米数据速率：100－420kbps SigfoxSigfox的范围在WiFi和蜂窝之间。它使用可免费使用的ISM频带，而不需要获取许可证，以便在非常窄的频谱范围内将数据传输到连接对象和从连接对象传输数据。 Sigfox的想法是，对于运行在小型电池上的许多M2M应用程序，只需要低级别的数据传输，则WiFi的范围太短，而蜂窝电话太贵，并且功耗太大。 Sigfox使用一种称为超窄带（UNB）的技术，仅用于处理每秒10至1，000位的低数据传输速度。与5000微瓦相比，蜂窝通信消耗的电量仅为50微瓦，或者可以通过2．5Ah电池提供典型的待机时间20年，而蜂窝电话仅为0．2年。已经部署在成千上万个连接对象中，该网络目前正在欧洲主要城市推出，其中包括英国的十个城市。该网络提供了一个强大的，功率高效和可扩展的网络，可以与数百万个电池供电设备在几平方公里的区域进行通信，使其适用于预期包括智能电表，病人监视器，安全设备，街道照明和环境传感器。 Sigfox系统使用Silicon Labs等EZRadioPro无线收发器等硅片，为在1GHz以下频段工作的无线网络应用提供行业领先的无线性能，扩展范围和超低功耗。1234标准：Sigfox频率：900MHz范围：30－50公里（农村环境），3－10公里（城市环境）数据速率：10－1000bps Neul与Sigfox相似，在1GHz频段内运行，Neul利用电视白空间频谱的小片，提供高可扩展性，高覆盖率，低功耗和低成本无线网络。系统基于Iceni芯片，其使用白色空间无线电进行通信，以访问高质量的UHF频谱，由于模拟到数字电视转换，现在可用。通信技术称为无重量，是一种为IoT设计的新型广域无线网络技术，与现有的GPRS，3G，CDMA和LTE WAN解决方案大有竞争。数据速率可以是在同一个单一链路上从每秒几位到100kbps的任何数据速率；并且设备可以从2xAA电池消耗少至20至30mA，这意味着在现场10至15年。1234标准：Neul频率：900MHz（ISM），458MHz（英国），470－790MHz（白色空间）范围：10公里数据速率：最少可达100kbps LoRaWANAgain在某些方面与Sigfox和Neul类似，LoRaWAN针对广域网（WAN）应用，旨在为具有特定功能的低功率WAN提供支持，以便在IoT，M2M和M2M中支持低成本移动安全双向通信智能城市和工业应用。针对低功耗优化并支持具有数百万和数百万台设备的大型网络，数据速率范围为0．3 kbps至50 kbps。1234标准：LoRaWAN频率：各种范围：2－5公里（城市环境），15公里（郊区环境）数据速率：0．3－50 kbps。]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim多文件之间的切换]]></title>
    <url>%2Fvim-multiple-files.html</url>
    <content type="text"><![CDATA[Quick Start打开多个文件 vim还没有启动的时候:12在终端里直接打开所有想要打开的文件vim file1 file2 ... filen vim启动打开多个文件: 12在编辑模式输入:e file 同时显示多个文件: 12:sp //水平切分窗口:vsplit //垂直切分窗口 在文件之间切换 一个文件切换到其他文件 12345Ctrl+6 //两文件间的切换:bn //下一个文件:bp //上一个文件:ls //列出打开的文件，带编号:b1~n //切换至第n个文件 在窗格间切换的方法对于用(v)split在多个窗格中打开的文件，这种方法只会在当前窗格中切换不同的文件。 123Ctrl+w+方向键——切换到前／下／上／后一个窗格Ctrl+w+h/j/k/l ——同上Ctrl+ww——依次向后切换到下一个窗格中]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux终端常用的快捷键]]></title>
    <url>%2FTerminal-Shortcut-keys.html</url>
    <content type="text"><![CDATA[Linux中的许多操作在终端（Terminal）中十分的快捷，记住一些快捷键的操作更得心应手。在Ubuntu中打开终端的快捷键是Ctrl+Alt+T。其他的一些常用的快捷键如下： 快捷键 功能 Tab 自动补全 Ctrl+a 光标移动到开始位置 Ctrl+e 光标移动到最末尾 Ctrl+k 删除此处至末尾的所有内容 Ctrl+u 删除此处至开始的所有内容 Ctrl+d 删除当前字符 Ctrl+h 删除当前字符前一个字符 Ctrl+w 删除此处到左边的单词 Ctrl+y 粘贴由Ctrl+u， Ctrl+d， Ctrl+w删除的单词 Ctrl+l 相当于clear，即清屏 Ctrl+r 查找历史命令 Ctrl+b 向回移动光标 Ctrl+f 向前移动光标 Ctrl+t 将光标位置的字符和前一个字符进行位置交换 Ctrl+&amp; 恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容 Ctrl+S 暂停屏幕输出 Ctrl+Q 继续屏幕输出 Ctrl+Left-Arrow 光标移动到上一个单词的词首 Ctrl+Right-Arrow 光标移动到下一个单词的词尾 Ctrl+p 向上显示缓存命令 Ctrl+n 向下显示缓存命令 Ctrl+d 关闭终端 Ctrl+xx 在EOL和当前光标位置移动 Ctrl+x@ 显示可能hostname补全 Ctrl+c 终止进程/命令 Shift+上或下 终端上下滚动 Shift+PgUp/PgDn 终端上下翻页滚动 Ctrl+Shift+n 新终端 alt+F2 输入gnome-terminal打开终端 Shift+Ctrl+T 打开新的标签页 Shift+Ctrl+W 关闭标签页 Shift+Ctrl+C 复制 Shift+Ctrl+V 粘贴 Alt+数字 切换至对应的标签页 Shift+Ctrl+N 打开新的终端窗口 Shift+Ctrl+Q 管壁终端窗口 Shift+Ctrl+PgUp/PgDn 左移右移标签页 Ctrl+PgUp/PgDn 切换标签页 F1 打开帮助指南 F10 激活菜单栏 F11 全屏切换 Alt+F 打开 “文件” 菜单（file） Alt+E 打开 “编辑” 菜单（edit） Alt+V 打开 “查看” 菜单（view） Alt+S 打开 “搜索” 菜单（search） Alt+T 打开 “终端” 菜单（terminal） Alt+H 打开 “帮助” 菜单（help）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu操作系统通过saltstack安装nginx]]></title>
    <url>%2Fsaltstack-install-nginx.html</url>
    <content type="text"><![CDATA[Quick Start新建nginx的state.sls文件12345678910nginx: pkgrepo.managed: - name: deb http://nginx.org/packages/ubuntu/ &#123;&#123;grains[&apos;oscodename&apos;]&#125;&#125; nginx - key_url: http://nginx.org/keys/nginx_signing.key - refresh_db: true - require_in: - pkg: nginx pkg.installed: - name: nginx 测试运行结果123456789101112131415161718192021222324252627salt &apos;*&apos; state.sls nginx test=Trueminion1:---------- ID: nginx Function: pkgrepo.managed Name: deb http://nginx.org/packages/ubuntu/ xenial nginx Result: None Comment: Package repo &apos;deb http://nginx.org/packages/ubuntu/ xenial nginx&apos; will be configured. This may cause pkg states to behave differently than stated if this action is repeated without test=True, due to the differences in the configured repositories. Started: 23:49:18.727125 Duration: 96.173 ms Changes:---------- ID: nginx Function: pkg.installed Result: None Comment: The following packages would be installed/updated: nginx Started: 23:49:22.886030 Duration: 3786.682 ms Changes:Summary for minion1------------Succeeded: 2 (unchanged=2)Failed: 0------------Total states run: 2Total run time: 3.883 s]]></content>
      <categories>
        <category>saltstack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu操作系统通过saltstack安装docker]]></title>
    <url>%2Fsaltstack-install-docker.html</url>
    <content type="text"><![CDATA[Quick StartDocker是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源，源代码部署在GitHub上，现已被广泛使用。常规情况下，Docker作为基础组件打在os的镜像里，对于后期加入管理的主机可通过saltstack进行批量安装。 新建docker的state.sls文件12345678910111213141516171819202122repository: pkg.installed: - pkgs: - apt-transport-https - curl - ca-certificates - software-properties-common - refresh: Truedocker-ce: pkgrepo.managed: - name: deb [arch=amd64] https://download.docker.com/linux/ubuntu &#123;&#123;grains[&apos;oscodename&apos;]&#125;&#125; stable - key_url: https://download.docker.com/linux/ubuntu/gpg - refresh_db: true - require: - pkg: repository - require_in: - pkg: docker-ce pkg.installed: - name: docker-ce - refresh: True 测试执行结果1234567891011121314151617181920212223242526272829303132333435salt &apos;*&apos; state.sls docker test=Trueminion1:---------- ID: repository Function: pkg.installed Result: None Comment: The following packages would be installed/updated: software-properties-common, apt-transport-https Started: 23:30:54.553191 Duration: 3797.25 ms Changes:---------- ID: docker-ce Function: pkgrepo.managed Name: deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable Result: None Comment: Package repo &apos;deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable&apos; will be configured. This may cause pkg states to behave differently than stated if this action is repeated without test=True, due to the differences in the configured repositories. Started: 23:30:58.355189 Duration: 114.982 ms Changes:---------- ID: docker-ce Function: pkg.installed Result: None Comment: The following packages would be installed/updated: docker-ce Started: 23:30:58.470868 Duration: 56.745 ms Changes:Summary for minion1------------Succeeded: 3 (unchanged=3)Failed: 0------------Total states run: 3Total run time: 3.969 s]]></content>
      <categories>
        <category>saltstack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum install nginx]]></title>
    <url>%2Fyum-install-nginx.html</url>
    <content type="text"><![CDATA[Quick Start新增nginx.repo文件cat /etc/yum.repos.d/nginx.repo12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 安装nginx1yum install nginx]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux设置默认编辑器]]></title>
    <url>%2FLinux-Set-Default-Editor.html</url>
    <content type="text"><![CDATA[Quick StartLinux设置默认编辑器为vi在使用edquota编辑限额时出现错误：1edquota: cannot exec /usr/bin/editor 根据错误提示，edquota命令没有找到可用的编辑器，于是设置系统默认的编辑器。在linux 中设置默认编辑器为vi1export EDITOR=vi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看操作系统版本]]></title>
    <url>%2FLinux-Get-OS-Release.html</url>
    <content type="text"><![CDATA[Quick StartUbuntulsb_release -a12345No LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 14.04.1 LTSRelease: 14.04Codename: trusty Centos方法一cat /etc/issue12CentOS release 6.8 (Final)Kernel \r on an \m 方法二cat /etc/redhat-release1CentOS release 6.8 (Final)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apt-get install JDK8]]></title>
    <url>%2Fapt-get-install-JDK8.html</url>
    <content type="text"><![CDATA[Quick Start安装python-software-properties12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 首先添加ppa1sudo add-apt-repository ppa:webupd8team/java 然后更新系统1sudo apt-get update 最后开始安装12345sudo apt-get install oracle-java8-installerjava -versionjava version “1.8.0_05&quot;Java(TM) SE Runtime Environment (build 1.8.0_05-b13) Java HotSpot(TM) Server VM (build 25.5-b02, mixed mode) java版本切换1sudo update-java-alternatives -s java-8-oracle]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云yum仓库镜像安装kubernetes]]></title>
    <url>%2Faliyum-install-kubernetes.html</url>
    <content type="text"><![CDATA[Quick Start安装kubernetes的时候，需要安装kubelet, kubeadm等包，但k8s官网给的yum源是packages.cloud.google.com，国内访问不了，此时我们可以使用阿里云的yum仓库镜像。注意不要开启check。 12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac install Kubernetes]]></title>
    <url>%2Fmac-install-Kubernetes.html</url>
    <content type="text"><![CDATA[Quick Start解决mac docker启动不了Kubernetes的问题docker for mac edge版新增了Kubernetes功能。但由于墙的问题，启动Kubernetes时，一直显示Kubernetes is starting.解决方法参考：https://github.com/maguowei/k8s-docker-for-mac docker版本： 先安装以上EDGE版如已安装，恢复出厂设置，参考docker官方文档。 配置本地私服Registry mirrors里增加http://registry.docker-cn.com， 注意不要用https，否则会提示证书错误 打开命令行工具，执行123git clone https://github.com/maguowei/k8s-docker-for-mac.gitcd k8s-docker-for-mac/./load_images.sh 按下图打勾，勾选k8s]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 install mysql5.7]]></title>
    <url>%2FUbuntu-16-04-install-mysql5-7.html</url>
    <content type="text"><![CDATA[Quick Start在Ubuntu 16.04版本的mysql数据库，默认是5.7版本的；123sudo apt-get updatesudo apt-get install mysql-server sudo mysql_secure_installation 更改数据库存储目录想要修改MySQL数据库存储的目录，需要了解mysql配置文件，以及apparmor的配置文件,这里提一下apparnor 是控制访问权限的，而mysql依赖它，所以不单单是改完mysql配置文件的内容，同样的需要修改apparmor的相应的配置文件。 创建MySQL另外存储的目录123mkdir /database/mysqlchmod 700 /database/mysqlchowd mysql:mysq /database/mysql 将以前的数据库复制到新的存储目录这样避免了再次初始化，并且数据还在1cp -av /var/lib/mysql/* /database/mysql 删除日志不删除会报错12rm -rf /database/mysql/ib_logfile0rm -rf /database/mysql/ib_logfile1 修改my.cnf12vim /etc/mysql/my.cnf 修改datadir=/var/lib/mysql 为你需要修改的目录 这里是 datadir=/database/mysql 修改apparmor的配置文件1234567vim /etc/apparmor/usr.sbin.mysqld将 /var/lib/mysql/ r, /var/lib/mysql/** rwk,修改为 /database/mysql/ r, /database/mysql/** rwk, reload apparmor的配置并重启这里不要停止apparmor服务，因为我在测试的时候关闭以后修改配置文件后反到是不成功， 直接修改后reload 然后重启12service apparmor reload service apparmor restart 重启mysql1service mysql restart 验证mysql的目录是否已经更改12进入mysql 命令行,执行：show variables like &apos;%datadir%’; 如果启动不了， 查看/var/log/mysql/error.log如果出现： InnoDB: The innodb_system data file ‘ibdata1’ must be writable 请仔细核对第5步，第6步如果出现启动成功，但是测试新建数据库还是在原来的目录， 试试重启服务器，或者仔细查看mysql配置文件，提醒一下 并不需要更改/usr/share/mysql/mysql-systemd-start 脚本中的datadir变量]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix-sender使用场景]]></title>
    <url>%2Fzabbix-sender.html</url>
    <content type="text"><![CDATA[Quick Start使用zabbix监控类型zabbix trapper，需要配合zabbix_sender给它传递数据，上报频率由客户端控制，通常用crontab来设置定时作业。一般情况下zabbix_sender会在以下几种场景使用： 执行超长时间脚本。这种情况下使用主动或被动模式都会超时，必须改成让客户端提交数据的方式。 客户端脚本一次执行得到多项采集数据时，通过zabbix_sender可以一次性上报多条结果，减少调用次数。 执行后数据有逻辑关和严谨性的，必须改成让客户端提交数据的方式，如取同一时刻的生产量和消耗量。 zabbix_sender命令详解语法： usage: zabbix_sender [-Vhv] {[-zpsI] -ko | [-zpI] -T -i &lt;file&gt; -r} [-c &lt;file&gt;] 使用参数： 1234567891011-c --config &lt;file&gt; 配置文件绝对路径-z --zabbix-server &lt;server&gt; zabbix server的IP地址-p --port &lt;server port&gt; zabbix server端口.默认10051-s --host &lt;hostname&gt; 主机名，zabbix里面配置的主机名（不是服务器的hostname），不能使用ip地址-I --source-address &lt;IP address&gt; 源IP-k --key &lt;key&gt; 监控项的key-o --value &lt;key value&gt; key值-i --input-file &lt;input file&gt; 从文件里面读取hostname、key、value 一行为一条数据，使用空格作为分隔符，如果主机名带空格，那么请使用双引号包起来-T --with-timestamps 一行一条数据，空格作为分隔符: &lt;hostname&gt; &lt;key&gt; &lt;timestamp&gt; &lt;value&gt;，配合 --input-file option，timestamp为unix时间戳-r --real-time 将数据实时提交给服务器-v --verbose 详细模式, -vv 更详细 zabbix_sender使用实例客户端主机为RedisServer，服务端IP为192.168.1.2，redis info 得到信息如下： 123456789……＃Clientsconnected_clients:2129client_longest_output_list:0client_biggest_input_buf:0blocked_clients:6…… 我们把clients的信息上传给zabbix server，zabbix item配置如下(其它值默认)： redis connected_clients: 1234567type: Zabbix trapperKey: redis.info[connected_clients]Type of information: Numberic (unsigned)Data type: Decimal redis client_longest_output_list: 1234567type: Zabbix trapperKey: redis.info[client_longest_output_list]Type of information: Numberic (unsigned)Data type: Decimal redis client_biggest_input_buf: 1234567type: Zabbix trapperKey: redis.info[client_biggest_input_buf]Type of information: Numberic (unsigned)Data type: Decimal redis blocked_clients: 1234567type: Zabbix trapperKey: redis.info[blocked_clients]Type of information: Numberic (unsigned)Data type: Decimal 1､ 提交单条数据： 1234zabbix_sender -s &quot;RedisServer&quot; -z 192.168.1.2 -k &quot;redis.info[connected_clients]&quot; -o 2129 -r`zabbix_sender -s &quot;RedisServer&quot; -z 192.168.1.2 -k &quot;redis.info[client_longest_output_list]&quot; -o 0 -r`zabbix_sender -s &quot;RedisServer&quot; -z 192.168.1.2 -k &quot;redis.info[client_biggest_input_buf]&quot; -o 0 -r`zabbix_sender -s &quot;RedisServer&quot; -z 192.168.1.2 -k &quot;redis.info[blocked_clients]&quot; -o 6 -r` 2、 指量提交数据： 123456789＃ cat redis_info.txt&quot;RedisServer&quot; &quot;redis.info[connected_clients]&quot; 2129&quot;RedisServer&quot; &quot;redis.info[client_longest_output_list]&quot; 0&quot;RedisServer&quot; &quot;redis.info[client_biggest_input_buf]&quot; 0&quot;RedisServer&quot; &quot;redis.info[blocked_clients]&quot; 6zabbix_sender -z 192.168.1.2 -i redis_info.txtinfo from server: &quot;processed: 4; failed: 0; total: 4; seconds spent: 0.000085&quot;sent: 4; skipped: 0; total: 4]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
</search>
